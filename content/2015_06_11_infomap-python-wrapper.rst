infomap-python-wrapper
######################

:date: 2015-6-11 11:09
:tags: GSoC, Infomap, Python
:category: GSoC
:slug: infomap-python-wrapper
:summary: 
:status: published


*******************
Plugging in Infomap
*******************

Currently only the  *Louvain* community detecion algorithm has been tested and integrated into a workflow.
The realm of community detection approaches is vast and many different approaches exist [1]_.
While the *Louvain* method is often the go-to approach when it comes to efficient *modularity* based community measures there is another efficient
choice of algorithm which follows a diffrent paradigm. The Infomap algorthm doesn't rely on modularity as a measruement to infer community but is
based on an information theoretic viewpoint (For more please see [2]_)


Using the Python wrapper
------------------------

The authors and inventors of the *Infomap* algorthm provide a performant C++ implementation along their theoretical work to the research community.
How to make use of their implementation in a productive high(er) level language like *Python*?
Enter *SWIG*: 

.. epigraph::

   *SWIG* is a software development tool that connects programs written in C and C++ with a variety of high-level programming languages. SWIG is used with different types of target languages including common scripting languages such as Javascript, Perl, PHP, **Python**, Tcl and Ruby.


SWIG is typically used to parse C/C++ interfaces and generate the 'glue code' required for the above target languages to call into the C/C++ code.

The Infomap source contains a specific directive in the makefile which allows to automatically generate these interfaces during the build process.

.. code-block:: shell

	swig -c++ -python [...] $(PY_BUILD_DIR)/infomap_wrap.cpp

With this the compiled static object (generated from the native Code) gets wrapped by a Python file which provides the SWIG interface and allows to
call methods directly from Python source. 

We can now naturally do

.. code-block:: Python

	# temporarily to manually update local path
	# sys.path.append(os.path.abspath('infomap'))

	from infomap import infomap

and are good to go.

Results
-------

Using the same preprocessing steps as for the *Louvain* method (time series extraction, correlation matrix, graph building through thresholding) we have the Graph in a variable ``G`` 

.. code-block:: Python

	G = nx.from_numpy_matrix(adjacenyMatrix).

.. code-block:: Python

	G.number_of_nodes(), G.number_of_edges()
	(81602, 804740)

which we can pass to a method which calls in turn through the SWIG interface the native code to Infomap.

.. code-block:: Python

	def findCommunities(G):
	"""
	Partition network with the Infomap algorithm.
	Annotates nodes with 'community' id and return number of communities found.
	"""
	conf = infomap.init("--two-level");
	# Input data
	network = infomap.Network(conf);
	# Output data
	tree = infomap.HierarchicalNetwork(conf)

	print "Building network..."
	for e in G.edges_iter():
		network.addLink(*e)

	network.finalizeAndCheckNetwork(True, nx.number_of_nodes(G));
	
	# Cluster network
	infomap.run(network, tree);
	codelength = tree.codelength()
	print "Codelength:", codelength

	communities = {}
	for leaf in tree.leafIter():
		communities[leaf.originalLeafIndex] = leaf.parentNode.parentIndex

	nx.set_node_attributes(G, 'community', communities)
	return tree.numTopModules()

The output generated by the Infomap algorithm is as follows:

.. code-block:: Python

	 numCommunities = findCommunities(G)
	
	=======================================================
	  Infomap v0.17.2 starts at [2015-06-11 15:01:45]
	  -> Configuration: two-level
	  -> Use undirected flow and 1st order Markov dynamics
	=======================================================
	Building network...
	 --> Found 81602 nodes and 804740 links.
	 --> Ignored 81602 self-links.
	 --> 11367 dangling nodes (nodes with no outgoing links).
	 ==> 81602 nodes and 723138 links.
	Calculating global flow...
	  -> Using undirected links.
	Calculating one-level codelength... done!
	  -> One-level codelength: 14.11430787

	Attempt 1/1 at [2015-06-11 15:01:48]
	Initiated to codelength 14.1143 + 2 = 16.11430787 in 81602 modules.
	Two-level compression: 30% 1.4% 0.16% 0.039% 0.014% 0.0045% 0.0041% to 20257 modules with codelength 9.670812527

	Building output tree with links...

	Best end modular solution in 2 levels:
	Per level number of modules:         [      20257,           0] (sum: 20257)
	Per level number of leaf nodes:      [          0,       81602] (sum: 81602)
	Per level average child degree:      [      20257,     4.02834] (average: 4031.8)
	Per level codelength for modules:    [0.839257614, 0.000000000] (sum: 0.839257614)
	Per level codelength for leaf nodes: [0.000000000, 8.831554913] (sum: 8.831554913)
	Per level codelength total:          [0.839257614, 8.831554913] (sum: 9.670812527)

	Codelength: 9.67081252689


.. code-block:: Python

	print "Number of communities found:", numCommunities
	Number of communities found: 20257
																	 
A modularity of 0.839257614 was achived. The algorithm partitioned the graph into 20257 different communities.
This is compareable to the results generated by the *Louvain* approach. 

+--------------------------+--------------------------+
| Infomap                  | Louvain                  |
+==========================+==========================+
| 0.839257614 (modularity) | 0.868138595 (modularity) |
+--------------------------+--------------------------+
| ~20k (communities)       | ~17k (communities))      |
+--------------------------+--------------------------+


Outlook
-------

Having a proof of concept for both the *Louvain* and *Infomap* in place we can place both approaches into a common framework.

Nescessary footwork to do:

- Interpreting the results and outputs of the algorithms in a princpled way 
- Determining an adequate way to give an useful output back to the end-user
- Software design which decouples common functionality in both algorithms from paradigm specific (modularity vs. information theoretic) optimization steps
- \+ decoupling of preprocessing steps (correlation Matrix computation) from actual algorithm

.. [1] Fortunato, S. (2009). Community detection in graphs. Physics Reports, 486(3), 75–174. http://doi.org/10.1016/j.physrep.2009.11.002
.. [2] Rosvall, M., & Bergstrom, C. T. (2008). Maps of random walks on complex networks reveal community structure. Pnas, 105(4), 1118–1123. http://doi.org/10.1073/pnas.0706851105